import json
import os
import csv
import boto3
import psycopg2
import uuid
import logging
import urllib.parse
import requests
from io import StringIO

# Configure logging
logger = logging.getLogger()
logger.setLevel(logging.INFO)

# Initialize AWS clients
s3_client = boto3.client('s3')

def get_db_connection():
    """Establish a connection to the PostgreSQL database"""
    try:
        conn = psycopg2.connect(
            host=os.environ['DB_HOST'],
            database=os.environ['DB_NAME'],
            user=os.environ['DB_USER'],
            password=os.environ['DB_PASSWORD']
        )
        return conn
    except Exception as e:
        logger.error(f"Database connection error: {str(e)}")
        raise e

def process_csv(file_content):
    """Process CSV content and return structured data"""
    csv_reader = csv.DictReader(StringIO(file_content))
    users = []
    
    for row in csv_reader:
        # Validate required fields for the new format
        required_fields = ['email', 'monthly_income', 'credit_score', 'employment_status', 'age']
        if not all(field in row for field in required_fields):
            logger.warning(f"Skipping row due to missing required fields: {row}")
            continue
            
        # Clean and validate data
        try:
            user = {
                # Use provided user_id if available, otherwise it will be auto-generated by DB
                'user_id': row.get('user_id'),
                'email': row['email'].strip().lower(),
                'monthly_income': float(row['monthly_income']),
                'credit_score': int(row['credit_score']),
                'employment_status': row['employment_status'].strip(),
                'age': int(row['age']),
                # Optional fields with defaults
                'debt_to_income_ratio': float(row.get('debt_to_income_ratio', 0)),
                'existing_loans': int(row.get('existing_loans', 0))
            }
            users.append(user)
        except (ValueError, TypeError) as e:
            logger.warning(f"Skipping row due to data validation error: {str(e)}, row: {row}")
            continue
    
    return users

def insert_users_to_db(conn, users, batch_id):
    """Insert processed user data into the database"""
    cursor = conn.cursor()
    inserted_count = 0
    
    for user in users:
        try:
            # Handle case where user_id is provided in the CSV
            if user.get('user_id'):
                cursor.execute(
                    """
                    INSERT INTO users (user_id, email, monthly_income, credit_score, employment_status, age, 
                                      debt_to_income_ratio, existing_loans, batch_id)
                    VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s)
                    ON CONFLICT (user_id) DO UPDATE SET
                        email = EXCLUDED.email,
                        monthly_income = EXCLUDED.monthly_income,
                        credit_score = EXCLUDED.credit_score,
                        employment_status = EXCLUDED.employment_status,
                        age = EXCLUDED.age,
                        debt_to_income_ratio = EXCLUDED.debt_to_income_ratio,
                        existing_loans = EXCLUDED.existing_loans,
                        updated_at = CURRENT_TIMESTAMP,
                        batch_id = EXCLUDED.batch_id
                    RETURNING user_id
                    """,
                    (
                        user['user_id'],
                        user['email'],
                        user['monthly_income'],
                        user['credit_score'],
                        user['employment_status'],
                        user['age'],
                        user['debt_to_income_ratio'],
                        user['existing_loans'],
                        batch_id
                    )
                )
            else:
                # Original behavior when no user_id is provided
                cursor.execute(
                    """
                    INSERT INTO users (email, monthly_income, credit_score, employment_status, age, 
                                      debt_to_income_ratio, existing_loans, batch_id)
                    VALUES (%s, %s, %s, %s, %s, %s, %s, %s)
                    ON CONFLICT (email) DO UPDATE SET
                        monthly_income = EXCLUDED.monthly_income,
                        credit_score = EXCLUDED.credit_score,
                        employment_status = EXCLUDED.employment_status,
                        age = EXCLUDED.age,
                        debt_to_income_ratio = EXCLUDED.debt_to_income_ratio,
                        existing_loans = EXCLUDED.existing_loans,
                        updated_at = CURRENT_TIMESTAMP,
                        batch_id = EXCLUDED.batch_id
                    RETURNING user_id
                    """,
                    (
                        user['email'],
                        user['monthly_income'],
                        user['credit_score'],
                        user['employment_status'],
                        user['age'],
                        user['debt_to_income_ratio'],
                        user['existing_loans'],
                        batch_id
                    )
                )
            inserted_count += 1
        except Exception as e:
            logger.error(f"Error inserting user {user['email']}: {str(e)}")
            continue
    
    conn.commit()
    return inserted_count

def trigger_n8n_webhook(batch_id):
    """Trigger the n8n webhook to start the matching workflow"""
    webhook_url = os.environ.get('N8N_WEBHOOK_URL')
    
    if not webhook_url:
        logger.warning("N8N_WEBHOOK_URL not configured, skipping webhook trigger")
        return False
    
    try:
        payload = {
            'batch_id': batch_id,
            'event': 'new_users_processed'
        }
        response = requests.post(webhook_url, json=payload)
        response.raise_for_status()
        logger.info(f"Successfully triggered n8n webhook: {response.status_code}")
        return True
    except Exception as e:
        logger.error(f"Error triggering n8n webhook: {str(e)}")
        return False

def handler(event, context):
    """Lambda handler function"""
    # Generate a unique batch ID for this processing run
    batch_id = str(uuid.uuid4())
    
    # Extract bucket and key from the S3 event
    bucket = event['Records'][0]['s3']['bucket']['name']
    key = urllib.parse.unquote_plus(event['Records'][0]['s3']['object']['key'])
    
    logger.info(f"Processing file {key} from bucket {bucket}")
    
    try:
        # Get the CSV file from S3
        response = s3_client.get_object(Bucket=bucket, Key=key)
        file_content = response['Body'].read().decode('utf-8')
        
        # Process the CSV data
        users = process_csv(file_content)
        logger.info(f"Processed {len(users)} valid user records from CSV")
        
        if not users:
            return {
                'statusCode': 400,
                'body': json.dumps({'message': 'No valid user records found in CSV'})
            }
        
        # Connect to the database
        conn = get_db_connection()
        
        # Insert users into the database
        inserted_count = insert_users_to_db(conn, users, batch_id)
        logger.info(f"Inserted/updated {inserted_count} users in the database")
        
        # Close database connection
        conn.close()
        
        # Trigger n8n webhook to start the matching workflow
        webhook_triggered = trigger_n8n_webhook(batch_id)
        
        return {
            'statusCode': 200,
            'body': json.dumps({
                'message': 'CSV processing completed successfully',
                'processed_records': len(users),
                'inserted_records': inserted_count,
                'batch_id': batch_id,
                'webhook_triggered': webhook_triggered
            })
        }
    except Exception as e:
        logger.error(f"Error processing CSV: {str(e)}")
        return {
            'statusCode': 500,
            'body': json.dumps({'message': f'Error processing CSV: {str(e)}'})
        }
